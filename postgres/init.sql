CREATE SCHEMA api;
CREATE SCHEMA extensions;

/* TABLES */
CREATE TABLE api.users (
	id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
	username TEXT NOT NULL UNIQUE,
	password TEXT NOT NULL,
	challenges BIT(128) NOT NULL DEFAULT B'0'::BIT(128),
	high_score INT NOT NULL DEFAULT 0,
	furthest_level INT NOT NULL DEFAULT 0,
	current_level INT NOT NULL DEFAULT 0,
	current_score INT NOT NULL DEFAULT 0,
	current_lives INT NOT NULL DEFAULT 3,
	augments TEXT[] NOT NULL DEFAULT ARRAY[]::TEXT[]
);

INSERT INTO api.users (username, password) VALUES
	('shaco', '123'), ('clone', '456'), ('kpoud2@gmail.com', 'password');

/* Sessions expire after db.session_timeout seconds of inactivity */
CREATE TABLE api.sessions (
	id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
	session_id UUID NOT NULL UNIQUE,
	start_time DATE NOT NULL DEFAULT CURRENT_TIMESTAMP
);

/* ROLES */
CREATE ROLE session_authorizer NOLOGIN;
GRANT USAGE ON SCHEMA api TO session_authorizer;
GRANT USAGE ON SCHEMA extensions TO session_authorizer;
GRANT SELECT, INSERT, UPDATE ON api.sessions TO session_authorizer;
GRANT SELECT, INSERT ON api.users TO session_authorizer;

CREATE ROLE test_server NOLOGIN;
GRANT USAGE ON SCHEMA api TO test_server;
GRANT SELECT, UPDATE ON api.users TO test_server;

CREATE ROLE web_anon NOLOGIN;
GRANT USAGE ON SCHEMA api TO web_anon;
GRANT SELECT(
	id,
	username,
	challenges,
	high_score,
	furthest_level,
	current_level,
	current_score,
	current_lives,
	augments
) ON api.users TO web_anon;
GRANT UPDATE(
	current_level,
	current_score,
	current_lives,
	augments
) ON api.users TO web_anon;
GRANT web_anon TO authenticator;

/* FUNCTIONS */
BEGIN;
CREATE FUNCTION api.signup(signup_username TEXT, signup_password TEXT)
RETURNS BOOLEAN AS $$
DECLARE
	exists BOOLEAN;
BEGIN
	exists := EXISTS(SELECT * FROM users WHERE username = $1);
	IF NOT exists THEN
		INSERT INTO users (username, password) VALUES ($1, $2);
		RAISE LOG 'Created new user %', $1;
		RETURN TRUE;
	END IF;
	RETURN FALSE;
END;
$$	LANGUAGE plpgsql
	SECURITY DEFINER
	SET search_path = api, pg_temp;
ALTER FUNCTION api.signup(signup_username TEXT, signup_password TEXT) OWNER TO session_authorizer;
REVOKE ALL ON FUNCTION api.signup(signup_username TEXT, signup_password TEXT) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION api.signup(signup_username TEXT, signup_password TEXT) TO web_anon;
COMMIT;

BEGIN;

/* If username and password match those of an existing user, create a session and return true */
/* On success, session_id is sent as a cookie */
CREATE FUNCTION api.login(login_username TEXT, login_password TEXT)
RETURNS BOOLEAN AS $$
DECLARE
	success BOOLEAN;
	new_session_id UUID;
	user_id INT;
BEGIN
	success := EXISTS(SELECT * FROM users WHERE username = $1 AND password = $2);
	IF success THEN
		user_id := (SELECT id FROM users WHERE username = $1);
		new_session_id := gen_random_uuid();
		INSERT INTO api.sessions (session_id) VALUES (new_session_id);
		/* TODO: Use HTTPS + 'Secure' in cookie */
		PERFORM set_config(
			'response.headers',
			format(
				'[
					{"Set-Cookie": "session_id=%s; Path=/api; Max-Age=%s; HttpOnly; SameSite=Lax"},
					{"Set-Cookie": "user_id=%s; Path=/; Max-Age=%s; SameSite=Lax"}
				]',
				new_session_id,
				current_setting('db.session_timeout'),
				user_id::TEXT,
				current_setting('db.session_timeout')
			),
			true
		);
		RETURN TRUE;
	END IF;
	RETURN success;
END;
$$	LANGUAGE plpgsql
	SECURITY DEFINER
	SET search_path = api, pg_temp;

ALTER FUNCTION api.login(login_username TEXT, login_password TEXT) OWNER TO session_authorizer;
REVOKE ALL ON FUNCTION api.login(login_username TEXT, login_password TEXT) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION api.login(login_username TEXT, login_password TEXT) TO web_anon;

COMMIT;

CREATE EXTENSION http SCHEMA extensions;

BEGIN;
CREATE FUNCTION api.login_google(google_id_token TEXT)
RETURNS BOOLEAN AS $$
DECLARE
    google_response JSON;
    user_email TEXT;
    user_sub TEXT;
    user_name TEXT;
    new_session_id UUID;
	user_id INT;
BEGIN
    -- Verify the Google token via Google's endpoint
    SELECT content::JSON INTO google_response
    FROM extensions.http_get(
        format('https://oauth2.googleapis.com/tokeninfo?id_token=%s', google_id_token)
    );
    -- Extract fields from Google response
    user_email := google_response->>'email';
    user_sub := google_response->>'sub';
    user_name := google_response->>'name';
	RAISE LOG 'Google login for %', user_email;

    IF user_email IS NULL OR user_sub IS NULL THEN 
        RETURN FALSE;
    END IF;

	IF NOT EXISTS(SELECT 1 FROM users WHERE LOWER(trim(username)) = LOWER(trim(user_email))) THEN
		INSERT INTO users (username, password) VALUES (user_email, user_sub);
		RAISE LOG 'Created new user for %', user_email;
	END IF;

	IF user_name IS NULL THEN
		user_name := user_email;
	END IF;
	user_id := (SELECT id FROM users WHERE username = $1);
	new_session_id := gen_random_uuid();
	INSERT INTO api.sessions (session_id) VALUES (new_session_id);
	/* TODO: Use HTTPS + 'Secure' in cookie */
	PERFORM set_config(
		'response.headers',
		format(
			'[
				{"Set-Cookie": "session_id=%s; Path=/api; Max-Age=%s; HttpOnly; SameSite=Lax"},
				{"Set-Cookie": "user_id=%s; Path=/; Max-Age=%s; SameSite=Lax"}
			]',
			new_session_id,
			current_setting('db.session_timeout'),
			user_id::TEXT,
			current_setting('db.session_timeout')
		),
		true
	);
	RETURN TRUE;
END;
$$ LANGUAGE plpgsql
   SECURITY DEFINER
   SET search_path = api, pg_temp;
ALTER FUNCTION api.login_google(google_id_token TEXT) OWNER TO session_authorizer;
REVOKE ALL ON FUNCTION api.login_google(google_id_token TEXT) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION api.login_google(google_id_token TEXT) TO web_anon;
COMMIT;


BEGIN;

CREATE FUNCTION validate_session()
RETURNS VOID AS $$
DECLARE
	current_session_id TEXT := current_setting('request.cookies', true)::JSON->>'session_id';
	request_path TEXT := current_setting('request.path', true);
BEGIN
	IF current_setting('request.method', true) = 'POST' AND request_path in ('/rpc/login', '/rpc/login_google', '/rpc/signup') THEN
		RETURN;
	END IF;
	IF NOT EXISTS(SELECT * FROM sessions WHERE session_id::TEXT = current_session_id) THEN
		RAISE EXCEPTION 'Could not validate session. Session not found.';
	END IF;
	IF EXISTS(SELECT * FROM sessions WHERE session_id::TEXT = current_session_id
		and AGE(start_time) >= format('%s seconds', current_setting('db.session_timeout'))::INTERVAL) THEN
		RAISE EXCEPTION 'Could not validate session. Session expired.';
	END IF;
END;
$$	LANGUAGE plpgsql
	SECURITY DEFINER
	SET search_path = api, pg_temp;

ALTER FUNCTION validate_session() OWNER TO session_authorizer;
REVOKE ALL ON FUNCTION validate_session() FROM PUBLIC;
GRANT EXECUTE ON FUNCTION validate_session() TO web_anon, test_server;

COMMIT;


/* FUNCTION TO PROCESS A COMPLETED LEVEL */
CREATE OR REPLACE FUNCTION api.complete_level(p_user_id INT, p_score_increase INT, challenge INT)
RETURNS VOID AS $$
DECLARE
    new_level INT;
BEGIN
    SELECT current_level + 1 INTO new_level FROM api.users WHERE id = p_user_id;
	UPDATE api.users SET challenges = set_bit(challenges, challenge, 1) WHERE id = p_user_id;
    UPDATE api.users
    SET	
        current_score = current_score + p_score_increase,
        current_level = new_level,
        furthest_level = GREATEST(furthest_level, new_level),
        high_score = GREATEST(high_score, current_score + p_score_increase)
    WHERE id = p_user_id;
END;
$$  LANGUAGE plpgsql;


/* FUNCTION TO ADD A CHOSEN AUGMENT TO A USER */
CREATE OR REPLACE FUNCTION api.add_augment(p_user_id INT, p_augment_key TEXT)
RETURNS VOID AS $$
DECLARE
    aug_type TEXT;
    aug_effect TEXT;
    aug_value NUMERIC; -- Use NUMERIC to handle potential decimals from multipliers
BEGIN
    -- This performs a lookup on the complete and correct hardcoded JSON data.
    SELECT
        aug->>'type', aug->>'effect', (aug->>'value')::NUMERIC
    INTO
        aug_type, aug_effect, aug_value
    FROM json_each(
        '{
            "INSTANT_POINTS_250": {"type": "INSTANT_EFFECT", "effect": "ADD_POINTS", "value": 250},
            "INSTANT_POINTS_500": {"type": "INSTANT_EFFECT", "effect": "ADD_POINTS", "value": 500},
            "INSTANT_LIFE_1": {"type": "INSTANT_EFFECT", "effect": "ADD_LIVES", "value": 1},
            "INSTANT_LIFE_3": {"type": "INSTANT_EFFECT", "effect": "ADD_LIVES", "value": 3},
            "PASSIVE_SCORE_BOOST": {"type": "PASSIVE_EFFECT", "effect": "MODIFY_BASE_POINTS", "value": 100},
            "PASSIVE_MULTIPLIER_SMALL": {"type": "PASSIVE_EFFECT", "effect": "MODIFY_POINT_MULTIPLIER", "value": 0.2},
            "PASSIVE_MULTIPLIER_LARGE": {"type": "PASSIVE_EFFECT", "effect": "MODIFY_POINT_MULTIPLIER", "value": 0.5}
        }'::json
    ) AS aug_data(key, aug)
    WHERE key = p_augment_key;

    IF aug_type = 'INSTANT_EFFECT' THEN
        -- Apply the effect immediately
        IF aug_effect = 'ADD_POINTS' THEN
            UPDATE api.users SET current_score = current_score + aug_value WHERE id = p_user_id;
        ELSIF aug_effect = 'ADD_LIVES' THEN
            UPDATE api.users SET current_lives = current_lives + aug_value WHERE id = p_user_id;
        END IF;
    ELSIF aug_type = 'PASSIVE_EFFECT' THEN
        -- Add the augment to the user's list of passive abilities
        UPDATE api.users SET augments = array_append(augments, p_augment_key) WHERE id = p_user_id;
    END IF;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION api.lose_life(user_id INT)
RETURNS INT AS $$
DECLARE
    lives_left INT;
BEGIN
    UPDATE api.users
    SET current_lives = current_lives - 1
    WHERE id = user_id
      AND current_lives > 0
    RETURNING current_lives INTO lives_left;

    -- If no update happened (already 0 lives), fetch current value
    IF NOT FOUND THEN
        SELECT current_lives INTO lives_left
        FROM api.users
        WHERE id = user_id;
    END IF;
	-- If lives left is 0, then reset to 3 and current level and score to 0, and augments to empty array
	IF lives_left = 0 THEN
		UPDATE api.users
		SET current_lives = 3,
			current_level = 0,
			current_score = 0,
			augments = ARRAY[]::TEXT[]
		WHERE id = user_id;
	END IF;
    RETURN lives_left;
END;
$$ LANGUAGE plpgsql;


CREATE FUNCTION on_sessions_update()
RETURNS TRIGGER AS $$
BEGIN
	DELETE FROM sessions WHERE AGE(start_time) >= format('%s seconds', current_setting('db.session_timeout'))::INTERVAL;
	RETURN NULL;
END;
$$	LANGUAGE plpgsql
	SECURITY DEFINER
	SET search_path = api, pg_temp;

CREATE TRIGGER on_sessions_update AFTER INSERT OR UPDATE ON api.sessions
	FOR EACH STATEMENT EXECUTE FUNCTION on_sessions_update();
